<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenManus POST-based Streaming Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin-top: 0;
            color: #333;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        textarea,
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        textarea {
            height: 100px;
            resize: vertical;
        }

        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }

        button:hover {
            background-color: #3b78e7;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .log-container {
            background-color: #f7f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            padding: 10px;
            margin-top: 20px;
            height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 13px;
        }

        .event {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }

        .event-system {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .event-agent {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
        }

        .event-browser {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
        }

        .event-error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .event-time {
            font-size: 11px;
            color: #666;
            margin-right: 10px;
        }

        .event-type {
            font-weight: bold;
            text-transform: uppercase;
            font-size: 11px;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
        }

        .event-type-system {
            background-color: #2196f3;
        }

        .event-type-agent {
            background-color: #ff9800;
        }

        .event-type-browser {
            background-color: #4caf50;
        }

        .event-type-error {
            background-color: #f44336;
        }

        .event-message {
            font-weight: 600;
            display: block;
            margin: 4px 0;
        }

        .event-content {
            margin-top: 5px;
        }

        .event-details {
            font-size: 12px;
            color: #333;
            max-height: 200px;
            overflow: auto;
        }

        .screenshot-container {
            margin-top: 10px;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        .screenshot-img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: block;
            margin-top: 5px;
        }

        .search-results {
            margin-top: 10px;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            overflow: hidden;
        }

        .search-header {
            padding: 8px 12px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
        }

        .search-header .search-icon {
            margin-right: 8px;
            color: #4285f4;
            font-size: 16px;
        }

        .search-header .search-query {
            font-weight: 600;
            flex-grow: 1;
        }

        .search-result-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .search-result-item {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-link {
            display: flex;
            color: #1a0dab;
            text-decoration: none;
            margin-bottom: 4px;
        }

        .search-result-link:hover {
            text-decoration: underline;
        }

        .search-result-favicon {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            margin-top: 3px;
        }

        .search-result-title {
            font-size: 16px;
            font-weight: 500;
        }

        .search-result-url {
            color: #006621;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .search-result-snippet {
            color: #545454;
            font-size: 13px;
            line-height: 1.4;
        }

        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 10px;
        }

        .status-connected {
            background-color: #e8f5e9;
            color: #2e7d32;
        }

        .status-disconnected {
            background-color: #ffebee;
            color: #c62828;
        }

        .status-connecting {
            background-color: #fff3e0;
            color: #ef6c00;
        }

        /* Page layout */
        .page-layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .main-content {
            flex: 1;
            margin: 0 auto;
        }
        
        .panels-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .left-panel {
            flex: 1;
            min-width: 0;
        }
        
        .right-panel {
            flex: 1;
            min-width: 0;
        }

        /* Memory panel styling */
        .memory-panel {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
            padding: 15px;
        }

        .memory-header {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .memory-section {
            margin-bottom: 15px;
            padding: 5px;
        }

        .memory-section-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: #444;
        }

        .agent-state-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .agent-pill {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            background-color: #f0f0f0;
            color: #555;
        }

        .agent-pill.active {
            background-color: #e3f2fd;
            color: #1976d2;
            font-weight: bold;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #bbdefb;
        }

        .agent-state {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 3px;
        }

        .agent-state-idle {
            background-color: #9e9e9e;
        }

        .agent-state-running {
            background-color: #4caf50;
            animation: pulse 1.5s infinite;
        }

        .agent-state-error {
            background-color: #f44336;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .memory-message {
            margin: 8px 0;
            padding: 8px 10px;
            border-radius: 4px;
            border-left: 3px solid #ddd;
            background-color: #f9f9f9;
            font-size: 13px;
        }

        .memory-message-role {
            font-weight: bold;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .memory-message-content {
            margin-top: 3px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .memory-message-meta {
            font-size: 11px;
            color: #999;
            margin-top: 3px;
            text-align: right;
            display: flex;
            justify-content: space-between;
        }
        
        .memory-message-contributor {
            font-weight: bold;
            color: #777;
        }

        .memory-message[data-role="system"] {
            border-left-color: #2196f3;
        }

        .memory-message[data-role="user"] {
            border-left-color: #ff9800;
        }

        .memory-message[data-role="assistant"] {
            border-left-color: #4caf50;
        }

        .memory-delta-indicator {
            font-size: 10px;
            background-color: #e8f5e9;
            color: #388e3c;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 5px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
        }
        
        .tab.active {
            color: #4285f4;
            border-bottom: 2px solid #4285f4;
        }

        .memory-message.highlight {
            animation: highlight-background 2s ease-in-out;
        }
        
        @keyframes highlight-background {
            0% { background-color: #f9f9f9; }
            30% { background-color: #e3f2fd; }
            100% { background-color: #f9f9f9; }
        }
        
        .agent-pill.highlight {
            animation: highlight-agent 2s ease-in-out;
        }
        
        @keyframes highlight-agent {
            0% { transform: scale(1); }
            30% { transform: scale(1.1); background-color: #bbdefb; }
            100% { transform: scale(1); }
        }
    </style>
</head>

<body>
    <div class="page-layout">
        <div class="main-content">
            <div class="container">
                <h1>OpenManus POST-based Streaming Demo</h1>

                <div class="input-group">
                    <label for="session-id">Session ID:</label>
                    <input type="text" id="session-id" placeholder="Leave blank to generate a random ID">
                </div>

                <div class="input-group">
                    <label for="query">Enter your query:</label>
                    <textarea id="query" placeholder="E.g., Plan a 3-day trip to Paris, France."></textarea>
                </div>

                <div>
                    <button id="connect-btn">Connect Stream</button>
                    <button id="submit-btn" disabled>Submit Query</button>
                    <button id="disconnect-btn" disabled>Disconnect</button>
                    <button id="clear-btn">Clear Logs</button>
                    <span id="connection-status" class="status status-disconnected">Disconnected</span>
                </div>

                <div class="panels-container">
                    <div class="left-panel">
                        <h3>Event Log</h3>
                        <div id="event-log" class="log-container"></div>
                    </div>
                    
                    <div class="right-panel">
                        <h3>Memory Panel</h3>
                        <div id="memory-panel" class="memory-panel">
                            <div class="memory-header">Shared Memory State</div>
                            <div class="memory-section">
                                <div class="memory-section-title">Agent States</div>
                                <div id="agent-states" class="agent-state-container"></div>
                            </div>
                            <div class="memory-section">
                                <div class="memory-section-title">Shared Memory Messages</div>
                                <div id="shared-memory"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Include the PostEventSource client -->
    <script src="stream-post-client.js"></script>

    <script>
        // DOM elements
        const sessionIdInput = document.getElementById('session-id');
        const queryInput = document.getElementById('query');
        const connectBtn = document.getElementById('connect-btn');
        const submitBtn = document.getElementById('submit-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const clearBtn = document.getElementById('clear-btn');
        const connectionStatus = document.getElementById('connection-status');
        const eventLog = document.getElementById('event-log');
        const memoryPanel = document.getElementById('memory-panel');
        const agentStatesContainer = document.getElementById('agent-states');
        const sharedMemoryContainer = document.getElementById('shared-memory');
        const tabs = document.querySelectorAll('.tab');

        // State variables
        let sessionId = null;
        let eventSource = null;
        let isConnected = false;
        
        // Memory state
        const memoryState = {
            agentStates: {},
            activeAgent: null,
            sharedMessages: [],
            messageContributors: {}
        };

        // Generate a random session ID
        function generateSessionId() {
            return 'session_' + Math.random().toString(36).substring(2, 15);
        }

        // Update UI based on connection status
        function updateConnectionUI(status) {
            isConnected = status === 'connected';

            // Update buttons
            connectBtn.disabled = isConnected;
            submitBtn.disabled = !isConnected;
            disconnectBtn.disabled = !isConnected;

            // Update status display
            connectionStatus.className = `status status-${status}`;
            connectionStatus.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }
        
        // Handle a memory update event
        function handleMemoryUpdate(eventDetails) {
            console.log('Memory update event:', eventDetails);
            
            // Debug - Check if this is shared or private memory
            if (eventDetails.privateMemory) {
                console.warn('PRIVATE MEMORY DETECTED IN UPDATE:', eventDetails);
                return; // Skip private memory updates
            }
            
            // Make sure we have a valid event
            if (!eventDetails) {
                console.error('Invalid memory update event: no details provided');
                return;
            }
            
            // Check if this is a delta update
            if (eventDetails.delta) {
                if (eventDetails.delta.type === 'private_memory_update') {
                    console.warn('PRIVATE MEMORY DELTA DETECTED:', eventDetails.delta);
                    return; // Skip private memory deltas
                }
                handleMemoryDelta(eventDetails);
            } else if (eventDetails.type === 'memory_update') {
                // Extract the actual memory data from event details
                const memoryData = eventDetails.details || eventDetails;
                
                // Check for private memory
                if (memoryData.privateMemory) {
                    console.warn('PRIVATE MEMORY FOUND IN DETAILS:', memoryData);
                    return; // Skip private memory updates
                }
                
                // Check if this has shared memory data
                if (memoryData.sharedMemory) {
                    initializeMemoryPanel(memoryData);
                } else if (memoryData.delta) {
                    // Handle case where delta is nested in details
                    if (memoryData.delta.type === 'private_memory_update') {
                        console.warn('NESTED PRIVATE MEMORY DELTA DETECTED:', memoryData.delta);
                        return; // Skip private memory deltas
                    }
                    handleMemoryDelta(memoryData);
                }
            } else {
                // Legacy full state update
                if (eventDetails.sharedMemory) {
                    initializeMemoryPanel(eventDetails);
                }
            }
        }
        
        // Handle a memory delta event
        function handleMemoryDelta(eventDetails) {
            console.log('PROCESSING MEMORY DELTA:', JSON.stringify(eventDetails, null, 2));
            
            // Skip private memory deltas
            if (eventDetails.type === 'private_memory_update' || 
                (eventDetails.target && eventDetails.target !== 'shared_memory')) {
                console.log('Skipping private memory delta:', eventDetails);
                return;
            }
            
            const { type, delta, accessor, timestamp } = eventDetails;
            console.log(`Delta type: ${type}, from: ${accessor}, timestamp: ${timestamp}`);
            console.log('Delta content:', delta);
            
            const updateTime = new Date(timestamp).toLocaleTimeString();
            
            switch (type) {
                case 'initialize':
                    console.log('Initializing memory panel with:', delta);
                    // Initialize memory panel with agent states
                    if (delta.agentStates) {
                        Object.entries(delta.agentStates).forEach(([agentId, state]) => {
                            updateAgentState(agentId, state);
                        });
                    }
                    
                    // If we have messages, initialize them
                    if (delta.messages && Array.isArray(delta.messages)) {
                        memoryState.sharedMessages = delta.messages;
                        renderSharedMemory();
                    }
                    
                    // Store message contributors if available
                    if (delta.messageContributors) {
                        memoryState.messageContributors = delta.messageContributors;
                    }
                    
                    // For a single agent registration
                    if (delta.agentId && delta.state) {
                        updateAgentState(delta.agentId, delta.state);
                    }
                    
                    // Set active agent if specified
                    if (delta.activeAgent) {
                        memoryState.activeAgent = delta.activeAgent;
                        renderAgentStates();
                    }
                    break;
                    
                case 'agent_state_updated':
                    // Update a single agent's state
                    if (delta.agentId && delta.state) {
                        updateAgentState(delta.agentId, delta.state);
                        
                        // Log the state change
                        const stateChangeMsg = {
                            role: 'system',
                            content: `Agent ${delta.agentId} state changed to ${delta.state}`,
                            timestamp
                        };
                        addMessageToSharedMemory(stateChangeMsg, accessor);
                    }
                    break;
                    
                case 'message_added':
                    // Add a new message to shared memory
                    if (delta.message) {
                        // Skip if this is for private memory
                        if (delta.target === 'private_memory') {
                            console.log('Skipping private memory message:', delta);
                            return;
                        }
                        
                        const { message, contributorId } = delta;
                        addMessageToSharedMemory(message, contributorId || accessor);
                    }
                    break;
                    
                case 'active_agent_changed':
                    // Update the active agent
                    if (delta.agentId) {
                        memoryState.activeAgent = delta.agentId;
                        renderAgentStates();
                        
                        // Log the agent change
                        const agentChangeMsg = {
                            role: 'system',
                            content: `Active agent changed to ${delta.agentId}`,
                            timestamp
                        };
                        addMessageToSharedMemory(agentChangeMsg, accessor);
                    }
                    break;
                    
                case 'plan_updated':
                case 'plan_step_updated':
                    // Add plan update notification
                    const planUpdateMsg = {
                        role: 'system',
                        content: type === 'plan_updated' 
                            ? `Plan for task "${delta.taskId}" created with ${delta.steps?.length || 0} steps` 
                            : `Step ${delta.stepIndex + 1} updated in plan "${delta.taskId}"`,
                        timestamp
                    };
                    addMessageToSharedMemory(planUpdateMsg, accessor);
                    break;
                    
                case 'agent_data_cleared':
                    // Add agent data cleared notification
                    const clearMsg = {
                        role: 'system',
                        content: `Data for agent ${delta.targetAgentId} cleared`,
                        timestamp
                    };
                    addMessageToSharedMemory(clearMsg, accessor);
                    
                    // Remove agent from UI if it exists
                    if (delta.targetAgentId) {
                        delete memoryState.agentStates[delta.targetAgentId];
                        renderAgentStates();
                    }
                    break;
                    
                default:
                    console.log(`Unknown memory delta type: ${type}`);
            }
        }
        
        // Initialize the memory panel with full state
        function initializeMemoryPanel(data) {
            const { sharedMemory, activeAgent, accessor } = data;
            
            // Clear existing state
            memoryState.agentStates = {};
            memoryState.sharedMessages = [];
            memoryState.activeAgent = activeAgent;
            
            // Set up agent states
            if (sharedMemory?.agentStates) {
                Object.entries(sharedMemory.agentStates).forEach(([agentId, state]) => {
                    memoryState.agentStates[agentId] = state;
                });
            }
            
            // Set up shared messages
            if (sharedMemory?.messages) {
                memoryState.sharedMessages = sharedMemory.messages;
            }
            
            // Render memory panel
            renderMemoryPanel();
        }
        
        // Update an agent's state and render
        function updateAgentState(agentId, state) {
            memoryState.agentStates[agentId] = state;
            renderAgentStates();
            
            // Highlight the updated agent pill
            setTimeout(() => {
                const agentPills = document.querySelectorAll('.agent-pill');
                agentPills.forEach(pill => {
                    if (pill.textContent.trim().includes(agentId)) {
                        pill.classList.add('highlight');
                        setTimeout(() => {
                            pill.classList.remove('highlight');
                        }, 2000);
                    }
                });
            }, 100);
        }
        
        // Add a message to shared memory
        function addMessageToSharedMemory(message, contributorId) {
            memoryState.sharedMessages.push(message);
            
            // Store contributor info
            const msgIndex = memoryState.sharedMessages.length - 1;
            memoryState.messageContributors[msgIndex] = contributorId;
            
            // Render the updated shared memory
            renderSharedMemory();
            
            // Highlight the most recent message
            setTimeout(() => {
                const messages = document.querySelectorAll('.memory-message');
                if (messages.length > 0) {
                    messages[0].classList.add('highlight');
                    setTimeout(() => {
                        messages[0].classList.remove('highlight');
                    }, 2000);
                }
            }, 100);
        }
        
        // Render the entire memory panel
        function renderMemoryPanel() {
            renderAgentStates();
            renderSharedMemory();
        }
        
        // Render agent states
        function renderAgentStates() {
            agentStatesContainer.innerHTML = '';
            
            Object.entries(memoryState.agentStates).forEach(([agentId, state]) => {
                const isActive = agentId === memoryState.activeAgent;
                const agentPill = document.createElement('div');
                agentPill.className = `agent-pill ${isActive ? 'active' : ''}`;
                
                const stateClass = state.toLowerCase();
                agentPill.innerHTML = `
                    <span class="agent-state agent-state-${stateClass}"></span>
                    ${agentId}
                `;
                
                agentStatesContainer.appendChild(agentPill);
            });
        }
        
        // Render shared memory messages
        function renderSharedMemory() {
            sharedMemoryContainer.innerHTML = '';
            
            if (memoryState.sharedMessages.length === 0) {
                sharedMemoryContainer.innerHTML = '<div class="memory-message">No messages in shared memory yet.</div>';
                return;
            }
            
            // Display most recent messages first (reverse order) - show ALL messages
            [...memoryState.sharedMessages].reverse().forEach((msg, index) => {
                const realIndex = memoryState.sharedMessages.length - 1 - index;
                const contributor = memoryState.messageContributors[realIndex] || 'system';
                const messageEl = createMessageElement(msg, contributor);
                sharedMemoryContainer.appendChild(messageEl);
            });
        }
        
        // Create a message element
        function createMessageElement(message, contributor) {
            const container = document.createElement('div');
            container.className = 'memory-message';
            container.setAttribute('data-role', message.role || 'unknown');
            
            // Create role element
            const roleEl = document.createElement('div');
            roleEl.className = 'memory-message-role';
            roleEl.textContent = message.role || 'unknown';
            
            // Create content element
            const contentEl = document.createElement('div');
            contentEl.className = 'memory-message-content';
            contentEl.textContent = message.content || '';
            
            // Create metadata element
            const metaEl = document.createElement('div');
            metaEl.className = 'memory-message-meta';
            
            // Add timestamp
            const timeEl = document.createElement('span');
            const messageTime = message.timestamp 
                ? new Date(message.timestamp).toLocaleTimeString() 
                : '';
            timeEl.textContent = messageTime;
            
            // Add contributor if available
            const contributorEl = document.createElement('span');
            contributorEl.className = 'memory-message-contributor';
            if (contributor) {
                contributorEl.textContent = `Added by: ${contributor}`;
            }
            
            metaEl.appendChild(timeEl);
            metaEl.appendChild(contributorEl);
            
            container.appendChild(roleEl);
            container.appendChild(contentEl);
            container.appendChild(metaEl);
            
            return container;
        }

        // Log an event to the event log
        function logEvent(type, message, details = null) {
            // Create event element
            const eventEl = document.createElement('div');
            eventEl.className = `event event-${type}`;

            // Format timestamp
            const time = new Date().toLocaleTimeString();

            // Check if there's image data in the details
            let imageHtml = '';
            if (details && (details.imageData || (details.details && details.details.imageData))) {
                const imageData = details.imageData || (details.details && details.details.imageData);
                const url = details.url || (details.details && details.details.url) || '';
                const pageTitle = details.title || (details.details && details.details.title) || '';

                if (imageData) {
                    imageHtml = `
                        <div class="screenshot-container">
                            <strong>Screenshot:</strong>
                            ${url ? `<div><strong>URL:</strong> ${url}</div>` : ''}
                            ${pageTitle ? `<div><strong>Page Title:</strong> ${pageTitle}</div>` : ''}
                            <img class="screenshot-img" src="${imageData}" alt="Screenshot" />
                        </div>
                    `;
                }
            }

            // Format details if they exist
            let detailsHtml = '';
            if (details) {
                // Extract search results from various potential sources
                let searchResults = [];
                let searchQuery = '';

                // Case 1: Direct results array in details
                if (details.results && Array.isArray(details.results) && details.results.length > 0) {
                    searchResults = details.results;
                    searchQuery = details.query || 'search query';
                }
                // Case 2: Web search tool result with search_results
                else if (details.search_results && Array.isArray(details.search_results) && details.search_results.length > 0) {
                    searchResults = details.search_results;
                    searchQuery = details.query || 'search query';
                }
                // Case 3: Nested in details object
                else if (details.details && details.details.results && Array.isArray(details.details.results)) {
                    searchResults = details.details.results;
                    searchQuery = details.details.query || 'search query';
                }
                // Case 4: Try to extract from fullResult if available
                else if (details.fullResult && typeof details.fullResult === 'string') {
                    try {
                        // Search for JSON_RESULTS comment
                        const jsonMatch = details.fullResult.match(/<!-- JSON_RESULTS: (.*?) -->/);
                        if (jsonMatch && jsonMatch[1]) {
                            try {
                                const parsedData = JSON.parse(jsonMatch[1]);
                                if (parsedData.results && Array.isArray(parsedData.results)) {
                                    searchResults = parsedData.results;
                                    searchQuery = parsedData.query || 'search query';
                                }
                            } catch (e) {
                                console.error('Error parsing JSON from comment:', e);
                            }
                        }

                        // Try to extract query from text if not found
                        if (!searchQuery) {
                            const queryMatch = details.fullResult.match(/Search results for "([^"]+)"/);
                            if (queryMatch && queryMatch[1]) {
                                searchQuery = queryMatch[1];
                            }
                        }
                    } catch (e) {
                        console.error('Error extracting search results from fullResult:', e);
                    }
                }

                // Format search results if found
                let searchResultsHtml = '';
                if (searchResults.length > 0) {
                    console.log(`Rendering ${searchResults.length} search results`);

                    searchResultsHtml = `
                        <div class="search-results">
                            <div class="search-header">
                                <span class="search-icon">🔍</span>
                                <span class="search-query">${searchQuery}</span>
                            </div>
                            <ul class="search-result-list">
                    `;

                    searchResults.forEach(result => {
                        const url = result.url || result.link || '#';
                        const title = result.title || 'No title';
                        const snippet = result.snippet || '';
                        let favicon = result.favicon || '';

                        // Generate favicon URL safely
                        if (!favicon) {
                            try {
                                if (url && url !== '#') {
                                    const hostname = new URL(url).hostname;
                                    favicon = `https://www.google.com/s2/favicons?domain=${hostname}`;
                                } else {
                                    favicon = 'https://www.google.com/s2/favicons?domain=example.com';
                                }
                            } catch (e) {
                                // Fallback for invalid URLs
                                favicon = 'https://www.google.com/s2/favicons?domain=example.com';
                            }
                        }

                        searchResultsHtml += `
                            <li class="search-result-item">
                                <a href="${url}" class="search-result-link" target="_blank">
                                    <img class="search-result-favicon" src="${favicon}" alt=""/>
                                    <span class="search-result-title">${title}</span>
                                </a>
                                <div class="search-result-url">${url}</div>
                                <div class="search-result-snippet">${snippet}</div>
                            </li>
                        `;
                    });

                    searchResultsHtml += `
                            </ul>
                        </div>
                    `;
                }

                // Try to stringify if it's an object
                let detailsText = '';
                if (typeof details === 'object') {
                    try {
                        // Remove base64_image and fullResult from JSON display to avoid huge output
                        const detailsCopy = JSON.parse(JSON.stringify(details));
                        if (detailsCopy.imageData) {
                            detailsCopy.imageData = '[base64 image data]';
                        }
                        if (detailsCopy.details && detailsCopy.details.imageData) {
                            detailsCopy.details.imageData = '[base64 image data]';
                        }
                        if (detailsCopy.base64_image) {
                            detailsCopy.base64_image = '[base64 image data]';
                        }
                        if (detailsCopy.fullResult) {
                            detailsCopy.fullResult = '[full result text]';
                        }

                        // Clean up results data in details display
                        if (detailsCopy.results) {
                            detailsCopy.results = `[${detailsCopy.results.length} search results]`;
                        }
                        if (detailsCopy.search_results) {
                            detailsCopy.search_results = `[${detailsCopy.search_results.length} search results]`;
                        }

                        detailsText = JSON.stringify(detailsCopy, null, 2);
                    } catch (e) {
                        detailsText = String(details);
                    }
                } else {
                    detailsText = String(details);
                }

                detailsHtml = `<pre class="event-details">${detailsText}</pre>`;

                // Add search results HTML before the details
                if (searchResultsHtml) {
                    detailsHtml = searchResultsHtml + detailsHtml;
                }
            }

            // Create event content
            let content = '';
            content += '<div class="event-header">';
            content += `<div class="event-time">${time}</div>`;
            content += `<div class="event-type event-type-${type}">${type.toUpperCase()}</div>`;
            content += '</div>';
            content += '<div class="event-content">';
            content += `<div class="event-message">${message}</div>`;
            content += imageHtml;
            content += detailsHtml;
            content += '</div>';

            // Add content to event element
            eventEl.innerHTML = content;

            // Append to log
            eventLog.appendChild(eventEl);

            // Scroll to bottom
            eventLog.scrollTop = eventLog.scrollHeight;

            // Handle memory delta events specially
            if (type === 'system' && details && details.type === 'memory_update') {
                handleMemoryUpdate(details);
            }
        }

        // Connect to the event stream
        function connectEventStream() {
            // Get session ID from input or generate a new one
            sessionId = sessionIdInput.value.trim() || generateSessionId();
            sessionIdInput.value = sessionId;

            // Update UI
            updateConnectionUI('connecting');
            logEvent('system', 'Connecting to event stream...', { sessionId });

            // Create new event source
            eventSource = new PostEventSource('/api/agent/stream-post', {
                sessionId,
                reconnectTimeout: 3000,
                maxReconnectAttempts: 5,
                connectionOptions: {
                    clientInfo: {
                        type: 'web',
                        userAgent: navigator.userAgent
                    }
                }
            });

            // Set up event listeners
            setupEventListeners();

            // Connect to the stream
            eventSource.connect();
        }

        // Disconnect from the event stream
        function disconnectEventStream() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }

            // Update UI
            updateConnectionUI('disconnected');
            logEvent('system', 'Disconnected from event stream');
        }

        // Set up event listeners for the event source
        function setupEventListeners() {
            // Connection events
            eventSource.addEventListener('open', () => {
                updateConnectionUI('connected');
                logEvent('system', 'Connected to event stream');
            });

            eventSource.addEventListener('error', (e) => {
                logEvent('error', 'Error in event stream', e.data);
            });

            eventSource.addEventListener('connecting', () => {
                updateConnectionUI('connecting');
                logEvent('system', 'Connecting to event stream...');
            });

            eventSource.addEventListener('reconnecting', (e) => {
                updateConnectionUI('connecting');
                logEvent('system', `Reconnecting (attempt ${e.data.attempt})...`);
            });

            eventSource.addEventListener('close', () => {
                updateConnectionUI('disconnected');
                logEvent('system', 'Connection closed');
            });

            // System events
            eventSource.addEventListener('system_start', (e) => {
                logEvent('system', e.data.message, e.data.details);
            });

            eventSource.addEventListener('system_end', (e) => {
                logEvent('system', e.data.message, e.data.details);
            });

            eventSource.addEventListener('system_error', (e) => {
                logEvent('error', e.data.message, e.data.details);
            });

            // Memory update events
            eventSource.addEventListener('memory_update', (e) => {
                try {
                    let eventData;
                    // Check if e.data is already an object or needs parsing
                    if (typeof e.data === 'string') {
                        eventData = JSON.parse(e.data);
                    } else {
                        eventData = e.data;
                    }
                    
                    console.log('Memory update event received:', eventData);
                    
                    // Filter out private memory updates - only process shared memory events
                    const isPrivateMemoryUpdate = 
                        eventData.type === 'private_memory_update' || 
                        (eventData.delta && eventData.delta.type === 'private_memory_update') ||
                        eventData.privateMemory;
                    
                    if (isPrivateMemoryUpdate) {
                        console.log('Ignoring private memory update:', eventData);
                        logEvent('system', `Private memory update ignored`, eventData);
                        return;
                    }
                    
                    // Log and process only shared memory updates
                    logEvent('system', `Shared memory update received`, eventData);
                    
                    // Make sure memory panel updates are reflected in the UI
                    handleMemoryUpdate(eventData);
                    
                    // Force UI update
                    renderMemoryPanel();
                } catch (err) {
                    console.error('Error parsing memory update event:', err, e.data);
                    logEvent('error', `Error parsing memory update: ${err.message}`, { rawData: e.data });
                }
            });

            // Agent events
            eventSource.addEventListener('agent_thinking', (e) => {
                // Only log to event log, don't add to shared memory
                logEvent('agent', `${e.data.agent} thinking: ${e.data.message}`, e.data.details);
            });

            eventSource.addEventListener('agent_acting', (e) => {
                // Only log to event log, don't add to shared memory
                
                // Check if this is a browser tool result with image data
                const isBrowserToolResult =
                    e.data.details &&
                    e.data.details.originalEvent === 'tool_result' &&
                    e.data.details.tool === 'browser' &&
                    e.data.details.imageData;

                // Check if this is a web search result
                const isWebSearchResult =
                    e.data.details &&
                    e.data.details.originalEvent === 'tool_result' &&
                    e.data.details.tool === 'web_search';

                if (isBrowserToolResult) {
                    logEvent('browser', `${e.data.agent} browser result: ${e.data.message}`, e.data.details);
                } else if (isWebSearchResult) {
                    // For web search tool results, extract and display results
                    let eventDetails = e.data.details;
                    // Process the search results if available
                    console.log('Processing web search results:', eventDetails);
                    logEvent('browser', `${e.data.agent} search results`, eventDetails);
                } else {
                    logEvent('agent', `${e.data.agent} acting: ${e.data.message}`, e.data.details);
                }
            });

            eventSource.addEventListener('agent_transition', (e) => {
                // Only log to event log, don't add to shared memory
                logEvent('agent', `Agent transition: ${e.data.message}`, e.data.details);
            });

            // Browser events
            eventSource.addEventListener('browser_navigate', (e) => {
                logEvent('browser', `Browser navigating to: ${e.data.details?.url || 'unknown'}`, e.data.details);
            });

            eventSource.addEventListener('browser_search', (e) => {
                logEvent('browser', `Browser searching for: ${e.data.details?.query || 'unknown'}`, e.data.details);
            });

            eventSource.addEventListener('browser_search_results', (e) => {
                logEvent('browser', `Browser search results for: ${e.data.details?.query || 'unknown'}`, e.data.details);
            });

            eventSource.addEventListener('browser_error', (e) => {
                logEvent('error', `Browser error: ${e.data.message}`, e.data.details);
            });

            eventSource.addEventListener('browser_screenshot', (e) => {
                logEvent('browser', `Browser screenshot captured`, e.data.details);
            });

            // Handle browser content events
            eventSource.addEventListener('browser_content', (e) => {
                logEvent('browser', `Browser content extracted`, e.data.details);
            });

            // Debug listener for all events
            eventSource.addEventListener('message', (e) => {
                console.log('Raw SSE message received:', e);
                try {
                    const eventData = JSON.parse(e.data);
                    console.log('Parsed event data:', eventData);
                } catch (err) {
                    console.error('Error parsing event data:', err);
                }
            });
        }

        // Submit a query
        async function submitQuery() {
            const query = queryInput.value.trim();

            if (!query) {
                alert('Please enter a query');
                return;
            }

            if (!sessionId) {
                alert('Please connect to the stream first');
                return;
            }

            // Disable submit button
            submitBtn.disabled = true;

            try {
                // Log query submission
                logEvent('system', 'Submitting query', { query });

                // Submit query
                const response = await fetch('/api/agent/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query,
                        sessionId
                    })
                });

                // Check for errors
                if (!response.ok) {
                    throw new Error('Error submitting query');
                }

                // Get response data
                const data = await response.json();

                // Log successful submission
                logEvent('system', 'Query submitted successfully', { sessionId: data.sessionId });
            } catch (error) {
                logEvent('error', `Error submitting query: ${error.message}`);
            } finally {
                // Re-enable submit button
                submitBtn.disabled = false;
            }
        }

        // Clear the event log
        function clearEventLog() {
            eventLog.innerHTML = '';
        }

        // Set up event listeners for UI
        connectBtn.addEventListener('click', connectEventStream);
        disconnectBtn.addEventListener('click', disconnectEventStream);
        submitBtn.addEventListener('click', submitQuery);
        clearBtn.addEventListener('click', clearEventLog);
    </script>
</body>

</html>
